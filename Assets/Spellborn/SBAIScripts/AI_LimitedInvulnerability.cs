using System;
using System.Collections.Generic;
using Engine;
using SBAI;
using SBGame;
using Sirenix.OdinInspector;
using UnityEngine;

namespace SBAIScripts
{
    [Serializable] public class AI_LimitedInvulnerability : AI_Script
    {
        [FoldoutGroup("AI_LimitedInvulnerability")]
        public bool Invulnerable;

        [FoldoutGroup("AI_LimitedInvulnerability")]
        public List<NPC_Taxonomy> ExceptFactions = new List<NPC_Taxonomy>();

        [FoldoutGroup("AI_LimitedInvulnerability")]
        public List<NPC_Type> ExceptNPC_Types = new List<NPC_Type>();

        [FoldoutGroup("AI_LimitedInvulnerability")]
        public bool ExceptPlayers;

        [FoldoutGroup("AI_LimitedInvulnerability")]
        public bool ExceptNPCs;

        [FoldoutGroup("AI_LimitedInvulnerability")]
        public bool ExceptSameFaction;

        [FoldoutGroup("AI_LimitedInvulnerability")]
        public bool ExceptSameNPC_Type;

        [FoldoutGroup("AI_LimitedInvulnerability")]
        public List<Content_Requirement> Exceptions = new List<Content_Requirement>();

        [FoldoutGroup("AI_LimitedInvulnerability")]
        public bool TriggerAble;

        [NonSerialized, HideInInspector]
        [FieldTransient()]
        public int Triggered;

        public AI_LimitedInvulnerability()
        {
        }
    }
}
/*
event UnTrigger(Actor Other,Pawn EventInstigator) {
if (TriggerAble) {                                                          
Triggered = Max(0,--Triggered);                                           
}
}
event Trigger(Actor Other,Pawn EventInstigator) {
if (TriggerAble) {                                                          
Triggered++;                                                              
}
}
function bool CheckInvulnerable(Game_AIController Victim,Actor cause) {
local Game_Pawn cause_pawn;
local Game_Pawn victim_pawn;
local export editinline NPC_Taxonomy cause_faction;
local export editinline NPC_Taxonomy victim_faction;
local export editinline NPC_Type cause_npc_type;
local int i;
local bool ExceptionsMet;
cause_pawn = Game_Pawn(cause);                                              
victim_pawn = Game_Pawn(Victim.Pawn);                                       
if (cause_pawn != None && victim_pawn != None) {                            
if (ExceptPlayers && cause_pawn.IsPlayerPawn()) {                         
return !Invulnerable;                                                   
}
if (ExceptNPCs
&& Game_NPCPawn(cause_pawn) != None) {             
return !Invulnerable;                                                   
}
cause_faction = cause_pawn.Character.GetFaction();                        
if (cause_faction != None) {                                              
if (ExceptSameFaction) {                                                
victim_faction = victim_pawn.Character.GetFaction();                  
if (cause_faction == victim_faction
|| victim_faction.IsParent(cause_faction)) {
return !Invulnerable;                                               
}
}
i = 0;                                                                  
while (i < ExceptFactions.Length) {                                     
if (cause_faction == ExceptFactions[i]
|| ExceptFactions[i].IsParent(cause_faction)) {
return !Invulnerable;                                               
}
i++;                                                                  
}
}
cause_npc_type = Game_NPCPawn(cause_pawn).NPCType;                        
if (cause_npc_type != None) {                                             
if (ExceptSameNPC_Type) {                                               
if (cause_npc_type == Game_NPCPawn(victim_pawn).NPCType) {            
return !Invulnerable;                                               
}
}
i = 0;                                                                  
while (i < ExceptNPC_Types.Length) {                                    
if (ExceptNPC_Types[i] == cause_npc_type) {                           
return !Invulnerable;                                               
}
i++;                                                                  
}
}
if (Exceptions.Length > 0 && cause_pawn != None) {                        
ExceptionsMet = True;                                                   
i = 0;                                                                  
while (i < Exceptions.Length) {                                         
if (Exceptions[i] != None
&& !Exceptions[i].CheckPawn(cause_pawn)) {
ExceptionsMet = False;                                              
goto jl027B;                                                        
}
i++;                                                                  
}
if (ExceptionsMet) {                                                    
return !Invulnerable;                                                 
}
}
}
return Invulnerable;                                                        
}
function bool OnDebuff(Game_AIController Victim,Game_Pawn aInstigator,export editinline FSkill_EffectClass aEffect,float aValue) {
if (TriggerAble && Triggered == 0) {                                        
return Super.OnDebuff(Victim,aInstigator,aEffect,aValue);                 
}
return CheckInvulnerable(Victim,aInstigator);                               
}
function bool OnBuff(Game_AIController Victim,Game_Pawn aInstigator,export editinline FSkill_EffectClass aEffect,float aValue) {
if (TriggerAble && Triggered == 0) {                                        
return Super.OnBuff(Victim,aInstigator,aEffect,aValue);                   
}
return CheckInvulnerable(Victim,aInstigator);                               
}
function bool OnDamage(Game_AIController Victim,Actor aInstigator,float aDamage) {
if (TriggerAble && Triggered == 0) {                                        
return Super.OnDamage(Victim,aInstigator,aDamage);                        
}
return CheckInvulnerable(Victim,aInstigator);                               
}
*/